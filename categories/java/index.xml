<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software</title>
    <link>http://yazilim.aykutasil.com/categories/java/index.xml</link>
    <description>Recent content on Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr-tr</language>
    <atom:link href="http://yazilim.aykutasil.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Android GcmNetworkManager Kullanımı</title>
      <link>http://yazilim.aykutasil.com/2017/01/android-gcmnetworkmanager-kullan%C4%B1m%C4%B1/</link>
      <pubDate>Wed, 11 Jan 2017 01:43:53 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/2017/01/android-gcmnetworkmanager-kullan%C4%B1m%C4%B1/</guid>
      <description>&lt;p&gt;GcmNetworkManager kullanarak Android de network tabanlı işlemlerinizi olabildiğince kontrollü bir şekide yapabilirsiniz.&lt;/p&gt;

&lt;p&gt;GcmNetworkManager ın kullanım alanı daha çok asenkron ve periodic network işlemlerinizi yapılandırmaktır.&lt;/p&gt;

&lt;p&gt;Tek sefer çalışacak veya Periodic olarak çalışacak işlemleriniz için 2 tip belirlenmiştir.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OneoffTask&lt;/li&gt;
&lt;li&gt;PeriodicTask&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;OneoffTask Kullanımı&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;OneoffTask oneoff = new OneoffTask.Builder()
        // Uygulamanızı kapatsanız bile tekrar açtığınız da network işleminiz işleme konulur.
        // Yani isteğinizin kalıcı olup olmamasını bu parametre ile ayarlayabilirsiniz.
        .setPersisted(true)
        // Belirtilen network işlemlerinin çalışacağı service i belirtir.
        .setService(MyGcmTaskService.class)
        // İşleminiz için tag belirleyebilirsiniz.
        // Aynı tag ile yeni bir istek yaptığınız da &#39;.setUpdateCurrent(true)&#39; olarak belirlenmiş ise isteğinizi yeni istek ile günceller. Yani eski isteğiniz geçersiz olacaktır. &#39;setUpdateCurrent(false)&#39; olarak belirlenir ise aynı tag ile yeni istekte bulunsanız bile her iki isteğiniz de çalışacaktır. 
        .setTag(tag)
        // Network isteğinizin çalışma zamanı parametrelerini belirler
        .setExecutionWindow(0, 10)
        // İşleminiz için internet gerekliliği veya wireless gerekliliği parametrelerini belirler
        .setRequiredNetwork(required_network_state)
        // İşleminiz için cihazın şarja bağlı olup olmaması gerekliliğini belirler
        .setRequiresCharging(false)
        // Aynı tag ile yeni istek yapıldığı takdirde güncellenip güncellenmemesi durumunu belirler
        .setUpdateCurrent(true)
        // Bundle ile işleminiz için gerekli parametreleri belirleyebilirsiniz
        .setExtras(bundle)
        // build eder
        .build();

GcmNetworkManager.getInstance(context).schedule(oneoff);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;MyGcmTaskService&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Cihazınızı yeniden başlatma gibi durumlar da önceden belirlenmiş task lerinizin çalışmasını devam ettirmesini istiyorsanız
// burada tekrar belirlemelisiniz.
@Override
public void onInitializeTasks() {
    
}

// GcmNetworkManager ın kendi algoritması ile seçilen, tanımlamış olduğunuz istek bu kod bloğuna girecek.
@Override
public int onRunTask(TaskParams taskParams) {
    try {
        Bundle bundle = taskParams.getExtras();
        return SchedulerRandevuTask(bundle);        
    } catch (Exception e) {
        ErrorEvent errorEvent = new ErrorEvent();
        errorEvent.setErrorContent(e.getMessage());
        EventBus.getDefault().post(errorEvent);
        return GcmNetworkManager.RESULT_RESCHEDULE;
    }
}

private int SchedulerZiyaretTask(Bundle bundle) {
    try {
        // isteğimiz sırasında bundle olarak yüklemiş olduğumuz nesneyi burada yakalıyoruz
        String jsonModel = bundle.getString(Const.IZTOP_TASK_BUNDLE);
        ZiyaretRequest request = new Gson().fromJson(jsonModel, ZiyaretRequest.class);
        ZiyaretResponse ziyaretResponse = sendZiyaretProcess(request);
        switch (ziyaretResponse.getCode()) {
            case 0: {
                EventBus.getDefault().post(ziyaretResponse);                
                // işlemlerimiz başarılı bir şekilde gerçekleşmiş ise result değeri olarak RESULT_SUCCESS dönüyoruz.
                // GcmNetworkManager bu işlemi başarılı olduğu için listeden silecek ve tekrar çalıştırmayı denemicektir.
                return GcmNetworkManager.RESULT_SUCCESS;
            }
            default: {
                // işlemlerimiz başarısız olması durumunda ( burada sunucuya istekte bulunulmuş ve dönen değer 0 değil ise başarısız olarak belirlenmiştir )isteğin tekrar çalışması için result değeri olarak RESULT_RESCHEDULE dönüyoruz.
                return GcmNetworkManager.RESULT_RESCHEDULE;
            }
        }
    } catch (Exception e) {
        SuperHelper.CrashlyticsLog(e);
        e.printStackTrace();
        return GcmNetworkManager.RESULT_RESCHEDULE;
    }


}
private ZiyaretResponse sendZiyaretProcess(ZiyaretRequest request) {
    return ApiManager.getInstance(getApplicationContext()).Ziyaret(request);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ApiManager / Ziyaret&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ZiyaretResponse Ziyaret(ZiyaretRequest request) {
    try {
        RestClient restClient = RestClient.getInstance();
        Call&amp;lt;ZiyaretResponse&amp;gt; responseCall = restClient.getApiService().Ziyaret(request);
        ZiyaretResponse ziyaretResponse = responseCall.execute().body();
        return ziyaretResponse;
    } catch (Exception ex) {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Retrofit ApiService&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@POST(&amp;quot;sunucu/ziyaret/api/adresi&amp;quot;)
Call&amp;lt;ZiyaretResponse&amp;gt; Ziyaret(@Body ZiyaretRequest ziyaretRequest);&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Android SMS Receiver</title>
      <link>http://yazilim.aykutasil.com/2017/01/android-sms-receiver/</link>
      <pubDate>Wed, 11 Jan 2017 01:42:54 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/2017/01/android-sms-receiver/</guid>
      <description>

&lt;h1 id=&#34;android-sms-receiver&#34;&gt;Android SMS Receiver&lt;/h1&gt;

&lt;p&gt;Android de gelen sms leri dinlemek ve uygulamanızın akışını gelen sms lere göre şekillendirmek için aşağıdaki yapıyı kullanabilirsiniz.&lt;/p&gt;

&lt;p&gt;İlk olarak AndroidManifest.xml dosyanızda receiver tanımlamalısınız. Fakat biz bu receiver ı dinamik olarak tanımlıcaz. Bunu yapmamızın sebebi SMS i dinledikten sonra bu receiver ı silmek ve daha sonra gelen SMS lerin dinlenmesini önlemek.&lt;/p&gt;

&lt;p&gt;Siz uygulamınız da sürekli bir SMS dinlemeye ihtiyaç duyarsanız receiver ı AndroidManifest.xml dosyanızda tanımlamalısınız.&lt;/p&gt;

&lt;p&gt;Biz burda SMS dinlemesi yaparken önlem amaçlı olarak CPU nun uyumasını önlüyoruz. Eğer bir işlem sonucunda sms gelmesini bekliyorsak, beklediğimiz SMS  geciktiği takdirde ve bu sırada cihazın ekranını vs. kapattığımız da Android cihazımız kendini uyku moduna almak isteyecektir. Bunu önlemek için &lt;strong&gt;WakefulBroadcastReceiver&lt;/strong&gt; yapısını kullanıyoruz. Bu yapı aslında Android in WakeLock özelliğini kullanan serviceler için özel olarak tasarlanmış  bir yapıdır. Cihazı uyanık tutar ve işimiz bittiği takdirde bu WakeLock u kaldırmamız gerekir. Bunu da service in içerisinde tanımlarız.&lt;/p&gt;

&lt;p&gt;Aşağıdaki fonksiyonu Activity miz içerisinde ihtiyacımız olan yerde çağırır ve SMS receiver ı çalıştırmıış oluruz.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LoginActivity&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void RegisterSmsReceiver() {
    SmsReceiver smsReceiver = new SmsReceiver();
    IntentFilter intentFilter = new IntentFilter(&amp;quot;android.provider.Telephony.SMS_RECEIVED&amp;quot;);
    android.os.Handler handler = new android.os.Handler();
    registerReceiver(smsReceiver, intentFilter, &amp;quot;android.permission.GET_TASKS&amp;quot;, handler);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SmsReceiver&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SmsReceiver extends WakefulBroadcastReceiver {

    private static final String TAG = &amp;quot;SmsReceiver&amp;quot;;

    public SmsReceiver() {
        super();
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        Intent myIntent = intent;
        myIntent.setClass(context, SmsReceiverService.class);

        // startWakeFulService ile AndroidManifest.xml dosyamız içerisinde tanımlamış olduğumuz Service e yönlendiriyoruz.
        // Ve cihazın uyanık kalmasını sağlıyoruz.
        startWakefulService(context, myIntent);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AndroidManifest.xml&lt;/strong&gt; dosyasında  Service imizi  tanımlıyoruz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;service
    android:name=&amp;quot;.SmsReceiverService&amp;quot;
    android:exported=&amp;quot;false&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exported=”false”&lt;/code&gt; tanımı servisin cihazda ki diğer uygulamalar tarafından çalıştırılamayacağını belirtir.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SmsReceiverService&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SmsReceiverService extends IntentService {

    private static final String TAG = &amp;quot;SmsReceiverService&amp;quot;;
    private Context context;

    public SmsReceiverService() {
        super(TAG);
    }

    @Override
    public void onCreate() {
        super.onCreate();
        context = getApplicationContext();
    }


    @Override
    protected void onHandleIntent(Intent intent) {

        String msg_from = null;
        String msgBody = null;
        if (intent.getAction().equals(&amp;quot;android.provider.Telephony.SMS_RECEIVED&amp;quot;)) {
            Bundle bundle = intent.getExtras();           //---get the SMS message passed in---
            SmsMessage[] msgs = null;

            if (bundle != null) {
                //---retrieve the SMS message received---
                try {
                    Object[] pdus = (Object[]) bundle.get(&amp;quot;pdus&amp;quot;);
                    msgs = new SmsMessage[pdus.length];
                    for (int i = 0; i &amp;lt; msgs.length; i++) {
                        msgs[i] = SmsMessage.createFromPdu((byte[]) pdus[i]);
                        msg_from = msgs[i].getOriginatingAddress();
                        msgBody = msgs[i].getMessageBody();

                    }
                } catch (Exception e) {
                     // Log.d(&amp;quot;Exception caught&amp;quot;,e.getMessage());
                }
            }
        }

        SmsEvent smsEvent = new SmsEvent();
        smsEvent.setActivationCode(&amp;quot;357&amp;quot;);
        smsEvent.setMsgBody(msgBody);
        smsEvent.setMsgFrom(msg_from);

        // EventBus ile sonucu istediğimiz yere gönderebiliriz.
        EventBus.getDefault().post(smsEvent);

        // Service in işini tamamladığını ve artık cihazın WakeLock u serbest bırakabileceğini söylüyoruz.
        SmsReceiver.completeWakefulIntent(intent);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SmsEvent&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SmsEvent {
    private String activationCode;
    private String msgFrom;
    private String msgBody;


    public String getActivationCode() {
        return activationCode;
    }

    public void setActivationCode(String activationCode) {
        this.activationCode = activationCode;
    }

    public String getMsgFrom() {
        return msgFrom;
    }

    public void setMsgFrom(String msgFrom) {
        this.msgFrom = msgFrom;
    }

    public String getMsgBody() {
        return msgBody;
    }

    public void setMsgBody(String msgBody) {
        this.msgBody = msgBody;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android Internet Connection Receiver </title>
      <link>http://yazilim.aykutasil.com/2017/01/android-internet-connection-receiver/</link>
      <pubDate>Wed, 11 Jan 2017 01:42:36 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/2017/01/android-internet-connection-receiver/</guid>
      <description>&lt;p&gt;Uygulamanızın akışını internet kontrolü yaparak yönetmeniz gerekebilir.&lt;/p&gt;

&lt;p&gt;Bunun için ilk olarak AndroidManifest.xml dosyasına receiver tanımı yapmalısınız.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;receiver android:name=&amp;quot;.InternetConnectionReceiver&amp;quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&amp;quot;android.net.conn.CONNECTIVITY_CHANGE&amp;quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;InternetConnectionReceiver&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InternetConnectionReceiver extends BroadcastReceiver {


    @Override
    public void onReceive(Context context, Intent intent) {

        if (CheckConnection(context)) {

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yukarıda tanımlanmış olan receiver, cihazın ağ yapısında herhangi bir değişiklik olduğunda bunu yakalar. Örneğin wireless açıkken kapattığınız da veya kapalıyken açtığınız da bunu yakayabilirsiniz.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CheckConnection&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static boolean checkConnection(Context con) {
    ConnectivityManager cm = (ConnectivityManager) con.getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo netInfo = cm.getActiveNetworkInfo();
    return netInfo != null &amp;amp;&amp;amp; netInfo.isConnectedOrConnecting();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yukarıda ki kod bloğu da cihazın internete bağlı olması durumunu kontrol eder.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Robolectric ile UnitTest Yazımı</title>
      <link>http://yazilim.aykutasil.com/2017/01/robolectric-ile-unittest-yaz%C4%B1m%C4%B1/</link>
      <pubDate>Wed, 11 Jan 2017 00:31:52 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/2017/01/robolectric-ile-unittest-yaz%C4%B1m%C4%B1/</guid>
      <description>&lt;p&gt;Unit Test birçok yazıılımcı tarafından es geçillen ama bir o kadar da önemli ve yapılması gerekli olan bir durumdur.&lt;/p&gt;

&lt;p&gt;Proje büyüdükçe ve ilerledikçe teste duyulan ihtiyaç ta doğru orantılı olarak artmaktadır.&lt;/p&gt;

&lt;p&gt;Unit Test neden yapılır sorusunun daha ayrıntılı cevabı için unit test nedir nicin ve nasil yapilir bu yazıyı okuyabilirsiniz.&lt;/p&gt;

&lt;p&gt;Android Studio da Robolectric kullanarak Unit Test Yazımı&lt;/p&gt;

&lt;p&gt;Aşağıdaki adımları sırası ile ve düzgün bir şekilde uygularsanız herhangi bir sorun çıkmadan testi çalıştırabileceksiniz.(Ben gerektiğinden uzun bi zaman harcadım, siz harcamayın !)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build.gradle&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;apply plugin: &#39;com.android.application&#39;

android {
    compileSdkVersion 22
    buildToolsVersion &amp;quot;23.0.0&amp;quot;

    defaultConfig {
        applicationId &amp;quot;com.a.aykut.tryrobolectric1&amp;quot;
        minSdkVersion 16
        targetSdkVersion 21
        versionCode 1
        versionName &amp;quot;1.0&amp;quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile &#39;com.android.support:appcompat-v7:22.2.1&#39;
    compile &#39;com.jakewharton:butterknife:7.0.1&#39;

    testCompile &#39;junit:junit:4.12&#39;
    testCompile &#39;com.squareup.assertj:assertj-android:1.1.0&#39;
    testCompile &#39;org.robolectric:robolectric:3.0&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MainActivity&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bind(R.id.button)
Button button;

@Bind(R.id.textView)
TextView textView;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  ButterKnife.bind(this);
}

@OnClick(R.id.button)
public void buttonClick(View vi) {
  textView.setText(&amp;quot;tiklandi&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AndroidManifest.xml  dosyasında herhangi bir değişiklik yapmanıza gerek yok.&lt;/p&gt;

&lt;p&gt;Test sınıfımızı yazmaya başlayalım.&lt;/p&gt;

&lt;p&gt;İlk olarak Android Studio nun sol tarafında yer alan &lt;strong&gt;Build Variant&lt;/strong&gt; tabından &lt;strong&gt;Test Artifact&lt;/strong&gt; kısmını &lt;strong&gt;Unit Tests&lt;/strong&gt; olarak değiştirin.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/rEPljpe&#34;&gt;&lt;img src=&#34;http://i.imgur.com/rEPljpe.jpg&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Unit Test yazmak için &lt;strong&gt;src&lt;/strong&gt; klasörüne test isminde bir klasör ve test klasörünün içine de &lt;strong&gt;java&lt;/strong&gt; isimli bir klasör oluşturmanız gerekmektedir.&lt;/p&gt;

&lt;p&gt;yani &lt;strong&gt;src/test&lt;/strong&gt; ve &lt;strong&gt;src/test/java&lt;/strong&gt; klasörlerini oluşturmalısınız.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/gztY5gr&#34;&gt;&lt;img src=&#34;http://i.imgur.com/gztY5gr.jpg&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Oluşturmuş olduğunuz java klasörüne sağ tıklayarak new &amp;gt; Package diyin ve normal Package isminizle aynı isimde bir Package oluşturun.Burda biz com.a.aykut.tryrobolectric1 ismini kullandık.&lt;/p&gt;

&lt;p&gt;Oluşturmuş olduğunuz Package sağ tıklayarak new &amp;gt; Java Class diyin ve test sınıfını oluşturun. Anlaşılabilirlik açısından Test*(Test Edilecek Sınıf ismi) olarak isimlendirebilirsiniz.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TestMainActivity&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import android.app.Activity;

import android.widget.Button;
import android.widget.TextView;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricGradleTestRunner;
import org.robolectric.annotation.Config;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertTrue;

@RunWith(RobolectricGradleTestRunner.class)
@Config(constants = BuildConfig.class,sdk = 21)
public class TestMainActivity {

  Activity activity;
  TextView textView;
  Button button;

  @Before
  public void setUp() {
    activity = Robolectric.setupActivity(MainActivity.class);
    textView = (TextView) activity.findViewById(R.id.textView);
    button = (Button) activity.findViewById(R.id.button);
  }

  @Test
  public void shouldMainActivityNotBeNull() throws Exception {
    Robolectric.buildActivity(MainActivity.class).create().pause().resume().get();
    assertTrue(Robolectric.buildActivity(MainActivity.class).create().get() != null);
    String hello = new MainActivity().getResources().getString(R.string.hello_world);
    assertEquals(hello, &amp;quot;Hello world!&amp;quot;);


  }

  @Test
  public void buttonClickChangeTextView() throws Exception {
    String text = textView.getText().toString();
    assertEquals(text, &amp;quot;Hello world!&amp;quot;);
    button.performClick();
    text = textView.getText().toString();
    assertEquals(text, &amp;quot;tiklandi&amp;quot;);

  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Evet.Test sınıfımızı da yazdık.Artık çalıştırabiliriz.&lt;/p&gt;

&lt;p&gt;Testimizi çalıştırmak için yazmış olduğumuz Test Sınıfına sağ tıklayarak Run diyoruz.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/7STeLHy&#34;&gt;&lt;img src=&#34;http://i.imgur.com/7STeLHy.jpg&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run dediğiniz de Test çalışacaktır. Fakat aşağıdaki hataya benzer bir hata alırsanız endişelenmeyin.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.RuntimeException: build\intermediates\bundles\debug\AndroidManifest.xml not found or not a file; it should point to your project&#39;s AndroidManifest.xml

at org.robolectric.manifest.AndroidManifest.validate(AndroidManifest.java:121)

at org.robolectric.manifest.AndroidManifest.getResourcePath(AndroidManifest.java:469)

at org.robolectric.manifest.AndroidManifest.getIncludedResourcePaths(AndroidManifest.java:475)

at org.robolectric.RobolectricTestRunner.createAppResourceLoader(RobolectricTestRunner.java:491)

at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
.

.

.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/1TpiUpG&#34;&gt;&lt;img src=&#34;http://i.imgur.com/1TpiUpG.jpg&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Resim de görüldüğü gibi &lt;strong&gt;Edit Configurations&lt;/strong&gt; a tıklayın.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/pFGTznR&#34;&gt;&lt;img src=&#34;http://i.imgur.com/pFGTznR.jpg&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Resim deki gibi &lt;strong&gt;Working directory&lt;/strong&gt; yolunun sonuna &lt;strong&gt;\app&lt;/strong&gt; ekleyin.&lt;/p&gt;

&lt;p&gt;Ve şimdi tekrar Test Sınıfına sağ tıklayarak Run diyin.&lt;/p&gt;

&lt;p&gt;Ve sonuç aşağıdaki gibi olmalıdır.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://imgur.com/zIgjUDT&#34;&gt;&lt;img src=&#34;http://i.imgur.com/zIgjUDT.jpg&#34; title=&#34;source: imgur.com&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kaynak kodlarını aşağıdkai linkten indirebilirsiniz.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/aykuttasil/RobolectricUnitTest&#34;&gt;https://github.com/aykuttasil/RobolectricUnitTest&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android ile WebView Etkileşimi</title>
      <link>http://yazilim.aykutasil.com/2016/12/android-ile-webview-etkile%C5%9Fimi/</link>
      <pubDate>Sun, 25 Dec 2016 00:28:10 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/2016/12/android-ile-webview-etkile%C5%9Fimi/</guid>
      <description>

&lt;p&gt;Kısa Hikaye : Üstünde çalışmakta olduğum bir projede kredi kartı ile ödeme yapısı kurmam gerekti. Kısaca projenin yapısından bahsedecek olursak&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Backend : .Net&lt;/li&gt;
&lt;li&gt;Client : Android (Java)&lt;/li&gt;
&lt;li&gt;Ödeme altyapısı : İyzico&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Client tarafında rest isteğiyle tüm işlemlerimizi backend tarafında yapıyoruz. Ödeme yapımızı da bu doğrultuda geliştirdik.&lt;/p&gt;

&lt;p&gt;Problem : 3DS ile ödeme almaya çalıştığımızda malumunuz işin içerisine bankanın bize telefonumuza gelen şifreyi girmemiz için göndermiş olduğu web sayfası vs. giriyor. Bu durumda client ile web sayfası iletişimini de bir şekilde sağlamamız gerekiyor.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Yukarıda ki hikayeyi anlatarak kafanızda bir problemi canlandırmaya çalıştım. Benzer bir çok durum ile karşı karşıya kalabilirsiniz.&lt;/p&gt;

&lt;p&gt;Ulan ben webview de ki butonu vs nasıl android tarafında kontrol edicem ? gibi akılda deli sorular oluşabilir..&lt;/p&gt;

&lt;p&gt;Tabiri caiz ise : PhoneGap tarzı bişiler.. 🙂 😉&lt;/p&gt;

&lt;p&gt;Neyse.&lt;/p&gt;

&lt;p&gt;Örnek ver hacı abi;&lt;/p&gt;

&lt;h2 id=&#34;layout-xml&#34;&gt;Layout.xml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;

    &amp;lt;WebView
        android:id=&amp;quot;@+id/WebView&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;activity-fragment&#34;&gt;Activity – Fragment&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WebView webView = (WebView) findViewById(R.id.WebView);

WebSettings settings = webView.getSettings();
settings.setDefaultTextEncodingName(&amp;quot;utf-8&amp;quot;);
settings.setJavaScriptEnabled(true);

webView.setWebViewClient(new MyWebViewClient());
webView.addJavascriptInterface(new MyWebViewJavascriptInterface(mContext, webView, callbackDialog), &amp;quot;Android&amp;quot;); // Buraya dikkat
webView.loadDataWithBaseURL(null, response.getData().getThreeDSHtmlContent(), &amp;quot;text/html&amp;quot;, &amp;quot;utf-8&amp;quot;, null); // elimizde bulunan bir html dökümanı webview e basıyoruz. URL de verebilirsin istersen
webView.addJavascriptInterface(new MyWebViewJavascriptInterface(mContext, webView, callbackDialog), &amp;quot;Android&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yukarıda ki “Android” kısmına istediğimiz ismi verebiliriz. WebView yapısı, burada belirtmiş olduğumuz isim ile sayfaya yüklenen içeriğe bir eklenti yapıyor, yani bir instance alıyor. Biz bu instance ı kullanarak iletişimimizi sağlıyoruz.&lt;/p&gt;

&lt;p&gt;Az sabır. Nasıl olduğunu görüceksin..&lt;/p&gt;

&lt;h2 id=&#34;mywebviewclient&#34;&gt;MyWebViewClient&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyWebViewClient extends WebViewClient {

    @Override
    public void onPageFinished(WebView view, String url) {
        super.onPageFinished(view, url);
        //view.loadUrl(&amp;quot;javascript:window.Android.processHTML(&#39;&amp;lt;html&amp;gt;&#39;+document.getElementsByTagName(&#39;html&#39;)[0].innerHTML+&#39;&amp;lt;/html&amp;gt;&#39;);&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bu blok ne yapıyor ?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;window.Android.processHTML&lt;/strong&gt; de ki Android bizim yukarıda belirtmiş olduğumuz aracı.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;processHtml&lt;/strong&gt; ise aşağıda tanımlıcak olduğumuz fonksiyon.&lt;/p&gt;

&lt;p&gt;Diğer kısımlar javascript fonksiyonu zaten. Yani sayfada ki ilk html tag ını bularak içindeki html kodu al.&lt;/p&gt;

&lt;p&gt;Aşağıda ki processHtml e bakarsan görüceksin ki htmlContent parametresi bekliyor.Biz de bu parametreye sayfa içeriğinin html kodunu gönderiyoruz. Almış olduğun bu html içeriğiyle ne yaparsın sana kalmış.&lt;/p&gt;

&lt;h2 id=&#34;mywebviewjavascriptinterface&#34;&gt;MyWebViewJavascriptInterface&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyWebViewJavascriptInterface {

    Context mContext;
    WebView mWebView;

    MyWebViewJavascriptInterface(Context c, WebView webView) {
        this.mContext = c;
        this.mWebView = webView;
    }

    @JavascriptInterface
    public void processHTML(String htmlContent) {
        // işlem
        // Toast ile html içeriğini gösterebiliriz       
    }

    @JavascriptInterface
    public void islemeDevamEt() {
       // işlem
    }

    @JavascriptInterface
    public void pencereyiKapat() {
        // işlem
        // dialog.dismiss();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WebView miz ile Android native kodumuzun iletişimini bu sınıf sağlıyor.&lt;/p&gt;

&lt;p&gt;Aşşağıda ki  kod ile bunu söylüyoruz.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;webView.addJavascriptInterface(new MyWebViewJavascriptInterface(mContext, webView), &amp;ldquo;Android&amp;rdquo;);&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Not&lt;/em&gt;&lt;/strong&gt; : Android 4.2 den sonra &lt;strong&gt;@JavascriptInterface&lt;/strong&gt; annotations ını eklememiz gerekmekte. Yoksa nolur ? Çalışmaz 😉&lt;/p&gt;

&lt;h2 id=&#34;custom-html-content&#34;&gt;Custom Html Content&lt;/h2&gt;

&lt;p&gt;WebView de gösterdiğimiz html contentinde bir buton ekleyelim.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; &amp;lt;button class=&amp;quot;btn btn-danger&amp;quot; onclick=&amp;quot;PencereyiKapat()&amp;quot;&amp;gt;Pencereyi Kapat&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WebView içinde ki bu butona basıldığını Android anlasın ve (WebView imizi Dialog içerisinde gösterildiğini varsayarak) dialog penceresini kapasın.&lt;/p&gt;

&lt;p&gt;Butonumuzun olduğu sayfaya  javascript kodumuzu ekliyoruz.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  function PencereyiKapat() {
     Android.pencereyiKapat();
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yukarıda ki Android i hatırladınız dimi ? 🙂&lt;/p&gt;

&lt;p&gt;HTML sayfamız bu kadar.&lt;/p&gt;

&lt;p&gt;WebView içerisinde ki butona basıldığında javascript fonksiyonu çalışacak ve Android.pencereyiKapat() çalışacak. Yani native tarafta tanımlamış olduğumuz pencereyiKapat() fonksiyonu.&lt;/p&gt;

&lt;p&gt;Yukarıda ki yapıyı kullanarak WebView – Android Native etkileşimli yapı kurabilirsin.&lt;/p&gt;

&lt;p&gt;Her zaman ki gibi hayal gücüne ve projeye kalmış 😉&lt;/p&gt;

&lt;p&gt;Kalın sağlıcakla..&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>