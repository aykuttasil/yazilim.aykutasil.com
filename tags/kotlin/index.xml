<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on Software</title>
    <link>http://yazilim.aykutasil.com/tags/kotlin/</link>
    <description>Recent content in Kotlin on Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr</language>
    <lastBuildDate>Sun, 27 Aug 2017 00:00:00 +0300</lastBuildDate>
    
	<atom:link href="http://yazilim.aykutasil.com/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android Architecture Components</title>
      <link>http://yazilim.aykutasil.com/post/android_arc_component/</link>
      <pubDate>Sun, 27 Aug 2017 00:00:00 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/android_arc_component/</guid>
      <description>Android Architecture Components Öncelikle şu linkleri verelim:
 https://developer.android.com/topic/libraries/architecture/index.html Lifecycle LiveData ViewModel  LifeCycle Daha önce Android uygulaması geliştirenler çok iyi bilirler ki bir activity veya fragment ın yaşam döngüsünü yönetmek sıkıntılı bir süreçtir. Activity&amp;rsquo;nin arka planda mı yoksa görünür vaziyette mi oluşuna göre düzenlenen akışlar çoğu zaman yoğun dikkat gerektiren süreçlerdir. Yukarıda ki Lifecycle linkine tıklarsanınz çok güzel bir örnek ile durumu açıklamışlar.
Oluşturduğumuz nesneler eğer activity&amp;rsquo;nin yaşam döngüsüne bağlı ise bunu yönetmek için activity&amp;rsquo;mizin genelde onCreate ve onStop metodları içerisinde bu nesnelere ait fonksiyonları çağırıyorduk.</description>
    </item>
    
    <item>
      <title>Kotlin @JvmOverloads</title>
      <link>http://yazilim.aykutasil.com/post/kotlin_jvmoverloads/</link>
      <pubDate>Sun, 09 Jul 2017 00:00:00 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/kotlin_jvmoverloads/</guid>
      <description>Kotlin @JvmOverloads Kotlin ile uygulama geliştirmeyi teşvik eden en büyük etkenlerden biri şüphesiz Java dili uyumlu yapısıdır. Her iki tarafdan da birbirlerine referanslar verilebilir.
Kotlin dilinin Java&amp;rsquo;dan ayıran özelliklerinden biri Java compiler ından daha zeki olmasıdır. Nitekim java dili yaşlanıyor :). Kotlin ile oluşturulan bazı yapıların Java tarafına uyumlu hale getirilmesi için bazen ufak düzenlemelere gerek duyulabiliyor. Bu düzenlemelerden bir tanesi de @JvmOverloads annotation kullanımı.
fun ViewGroup.inflate(resId: Int, attachToRoot: Boolean = false): View { return LayoutInflater.</description>
    </item>
    
    <item>
      <title>Kotlin Sealed Class</title>
      <link>http://yazilim.aykutasil.com/post/kotlin_sealed_class/</link>
      <pubDate>Sat, 01 Jul 2017 00:00:00 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/kotlin_sealed_class/</guid>
      <description>Kotlin Sealed Class Enum yapısına benzer bir yapıya sahiptir. Ve benzer görevler için kullanılır. Aradaki fark enum lar sabit değer ifade etmek için kullanılırken sealed yapısı normal sınıf gibi fakat enum mantığıyla kullanılır. Yani belli bir duruma ait fonksiyonları bir arada tutmak ve when() gibi fonksiyonlar ile birlikte kullanımını sağlamak için kullanılır.
// Sealed class enum yapısına benzer // Bir durum için belli başlı akışları bir arada tutmamızı sağlar ve bu akışların yönetimini kolaylaştırır.</description>
    </item>
    
    <item>
      <title>Kotlin Lambda</title>
      <link>http://yazilim.aykutasil.com/post/kotlin_lambda/</link>
      <pubDate>Sun, 18 Jun 2017 02:24:37 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/kotlin_lambda/</guid>
      <description>Kotlin Lambda Kullanımı Kotlin dili ile geliştirme yaparken fonksiyonel programlama nimetlerinden faydalanmamızı sağlayan lambda birçok konuda bize yardımcı olacaktır. Doğru kullanımını öğrendiğimiz ölçüde nimetlerinin farkına varabiliriz.
Belli başlı lambda kullanımları için aşağıdaki örneği inceleyebilirsiniz.
 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_kotlin_lambda) // Normal Kullanım ButtonPress.setOnClickListener(object : View.OnClickListener { override fun onClick(view: View?) { toast(&amp;quot;Press Me Click&amp;quot;) } }) // Yukarıda ki yapıyı lambda kullanarak bu şekle çevirebiliriz ButtonPress.setOnClickListener({ v -&amp;gt; toast(&amp;quot;Press Me&amp;quot;) }) // Eğer son parametre lambda fonksiyonu ise bu fonksiyonu parantez &#39;()&#39; dışına çıkarabiliriz.</description>
    </item>
    
    <item>
      <title>Kotlin apply Kullanımı</title>
      <link>http://yazilim.aykutasil.com/post/kotlin_apply/</link>
      <pubDate>Tue, 06 Jun 2017 10:47:58 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/kotlin_apply/</guid>
      <description>fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }  apply() tüm tipler için belirlenmiş bir extension function dır. apply() fonksiyonu uygulanan nesnenin özelliklerine direk olarak apply kod bloğu içerisinden erişilebilir.
var file = File(dir) file.mkdirs()  veya Java ile yazacak olursak
File makeDir(String path) { File result = new File(path); result.mkdirs(); return result; }  Bu kodu aşağıdaki yapıya çevirebiliriz.
File(dir).apply { mkdirs() }  </description>
    </item>
    
    <item>
      <title>Kotlin when kullanımı</title>
      <link>http://yazilim.aykutasil.com/post/kotlin_when/</link>
      <pubDate>Tue, 06 Jun 2017 04:42:56 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/kotlin_when/</guid>
      <description>Kotlin&amp;rsquo;de when operatörü oldukça işimizi kolaylaştıran operatörlerden biridir.
if- else if yapısı yerine kullanılabileceği gibi bazı yardımcı operatörler ile birçok marifet kazanabilir.
 val i = 10 when { i &amp;lt; 7 -&amp;gt; println(&amp;quot;first block&amp;quot;) fooString.startsWith(&amp;quot;hello&amp;quot;) -&amp;gt; println(&amp;quot;second block&amp;quot;) else -&amp;gt; println(&amp;quot;else block&amp;quot;) }  Yukarıda ki örnek if-else if-else yapısının aynısıdır.
 when (i) { 0, 21 -&amp;gt; println(&amp;quot;0 or 21&amp;quot;) in 1..20 -&amp;gt; println(&amp;quot;in the range 1 to 20&amp;quot;) else -&amp;gt; println(&amp;quot;none of the above&amp;quot;) }  Yukarıda ki gibi aralıklar tanımlanabilir ve bu aralıklara uyum kontrolü yapılarak ilgili işlemlerin yapılması sağlanılabilir.</description>
    </item>
    
    <item>
      <title>Kotlin Let Kullanımı</title>
      <link>http://yazilim.aykutasil.com/post/kotlin_let/</link>
      <pubDate>Tue, 06 Jun 2017 04:33:06 +0300</pubDate>
      
      <guid>http://yazilim.aykutasil.com/post/kotlin_let/</guid>
      <description>Kotlin fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)  let() temel olarak, belirli bir kapsam için bir değişken/kod bloğu oluşturmamızı sağlayan bir kapsamlayıcı işlevdir. Yani let() bir sarmalıyıcı fonksiyondur.
Örneğin:
private var mPhotoUrl: String? = null fun uploadClicked() { if (mPhotoUrl != null) { uploadPhoto(mPhotoUrl!!) } }  Yukarıda ki if (mPhotoUrl != null) satırı ile null kontrolü yapılır ve eğer null değilse uploadPhoto(mPhotoUrl!!) kod bloğu çalıştırılır.</description>
    </item>
    
  </channel>
</rss>